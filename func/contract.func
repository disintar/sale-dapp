#pragma version >=0.2.0;

#include "asm/helpers.func";
#include "asm/dump-utils.func";
#include "op_codes.func";
#include "magic_constants.func";
#include "storage.func";

#include "messages.func";
#include "get_methods.func";
#include "admin_methods.func";


(slice, int) parse_in_msg(cell in_msg_full_cell) inline {
    slice cs = in_msg_full_cell.begin_parse();
    int flags = cs~load_uint(4);

    slice sender_address = cs~load_msg_addr();

    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = cs~load_coins(); ;; we use message fwd_fee for estimation of forward_payload costs

    return (sender_address, fwd_fee);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    (slice message_from, int fwd_fee) = parse_in_msg(in_msg_full);

    ;; TODO: Allow multiple assets
    ;; handle internal messages
    (int mode,
            slice nft_address,
            slice deployer_address,
            slice buyer,
            cell sell_config,
            cell price_config) = load_data();

    ~strdump_int("Contract mode", mode);
    ;; uninited mode, wait for nft
    if (mode == 0) {
        if (equal_slices(message_from, deployer_address)) {
            if (slice_bits(in_msg_body) >= 32) {
                ;; TODO: test admin interface
                ;; try process admin messages
                int op = in_msg_body~load_uint(32);
                int exit_code = process_admin(op, in_msg_body);
                throw(exit_code);
            } else {
                ;; Just allow deploy from deployer

                ;; If there will be an jetton sale
                ;; Allow to set own jetton address on initialization
                if (slice_bits(in_msg_body) > 2) {
                    if (in_msg_body.preload_uint(2) != 0) {
                        slice expected_jetton_address = in_msg_body~load_msg_addr();
                        cell new_price_config = repack_price_config_with_jetton_address(price_config, expected_jetton_address);

                        store_data(0,
                                nft_address,
                                deployer_address,
                                buyer,
                                sell_config,
                                new_price_config);
                    }
                }
                throw(0);
            }
        }

        ;; It's easy just to drop all messages
        ;; But if we fucked up and got diffrent NFT / FT it'll be burned
        ;; So I want to add transfer of NFT back, not just bounce
        ;;         ;; here we need to drop all messages from all addresses
        ;;         ;; except nft, which we expect
        ;;         throw_unless(228, equal_slices(message_from, nft_address));

        ;; ownership_assigned#05138d91 query_id:uint64 prev_owner:MsgAddress
        ;; forward_payload:(Either Cell ^Cell) = InternalMsgBody;

        int op = in_msg_body~load_uint(32);
        int query_id = in_msg_body~load_uint(64);
        slice prev_owner_address = in_msg_body~load_msg_addr();


        ;; We expect thet previus owner of nft is deployer of this contract
        int deployer_is_prev_owner = equal_slices(prev_owner_address, deployer_address);

        ;; We expect NFT to be the same as in contract
        int is_our_nft = equal_slices(message_from, nft_address);

        ;; We expect op to be ownership_assigned
        int is_ownership_assigned = op == op::nft::ownership_assigned;

        if (is_our_nft & is_ownership_assigned & deployer_is_prev_owner) {
            ;; All good, need to initialize contract
            store_data(1,
                    nft_address,
                    deployer_address,
                    buyer,
                    sell_config,
                    price_config);
            throw(0);
        } elseif (op == op::nft::ownership_assigned) {
            ;; We got not our nft
            ;; Try to send it back

            ;; First we need to validate money
            ;; Is it enough to run previus code, pay for storage, and send message
            int new_fwd_amount = msg_value - little_gas_amount - fwd_fee;
            throw_unless(229, new_fwd_amount > 0);

            send_nft(message_from, prev_owner_address, new_fwd_amount + fwd_fee);
            throw(0);
        } else {
            send_money_or_jettons_back_op(op, in_msg_body, message_from, msg_value, fwd_fee, "Error ü•ÇÔ∏è");
        }
    } elseif (mode == 1) { ;; Seller is inited
        ;; Change settings & admin control

        if (equal_slices(message_from, deployer_address)) {
            ~strdump_safe("Process message from deployer");

            ;; Here we can buy NFT or change settings
            int op = in_msg_body~load_uint(32);

            ;; Change price
            if (op == op::seller::update_sale) {
                ~strdump_safe("Process update sale");

                ;; TODO: add tests
                cell new_price_config = in_msg_body~load_ref();
                store_data(1,
                        nft_address,
                        deployer_address,
                        buyer,
                        sell_config,
                        new_price_config);
                throw(0);
            } elseif (op == op::seller::cancel_sell) {
                ~strdump_safe("Process cancel sale");

                ;; TODO: add tests
                store_data(3, ;; set contract to close
                        nft_address,
                        deployer_address,
                        buyer,
                        sell_config,
                        price_config);

                raw_reserve(100000, 0); ;; save little ammount
                send_nft(nft_address, deployer_address, -1); ;; transfer nft back to owner
                throw(0);
            } else {
                ~strdump_safe("Command not found");
                send_money_or_jettons_back_op(op, in_msg_body, message_from, msg_value, fwd_fee, "Error üç≠");
            }

            ;; Here we can't allow admin commands
            ;; Because seller can transfer NFT back
            ;; Need to think of limitations on sending transfer messages to assets inside contract
            ;;             else { ;; or process admin stuff
            ;;                 int exit_code = process_admin(op, in_msg_body);
            ;;                 throw(exit_code);
            ;;             }
        }  else {
            ~strdump_safe("Process buy request üí∏");

            ;; Try to buy
            (int marketplace_numerator,
                    int marketplace_denominator,
                    int royalty_numerator,
                    int royalty_denominator,
                    slice royalty_destanation) = parse_sell_config(sell_config);

            (int is_ton,
                    int price,
                    slice limited_address,
                    int end_at,
                    slice my_jetton_address) = parse_price_config(price_config);

            int market_fee = 0;
            int royalty_fee = 0;

            ifnot (preload_uint(limited_address, 2) == 0) {
                ~strdump_safe("Sale is limited, check üîê");

                ifnot (equal_slices(message_from, limited_address)) {
                    ~strdump_safe("Not for you ‚ù§Ô∏è");
                    send_money_or_jettons_back_body(in_msg_body, message_from, msg_value, fwd_fee, "Not for you ‚ù§Ô∏è");
                }

                ~strdump_safe("Sale is limited, all good üîì");
            }

            ;; TODO: test this
            if ((end_at != 0) & (now() >= end_at)) {
                store_data(3, ;; set contract to close
                        nft_address,
                        deployer_address,
                        buyer,
                        sell_config,
                        price_config);

                ;; Send money back
                int new_fwd_amount = msg_value - fwd_fee - little_gas_amount;

                ;; Need 100% sure this willn't fail
                if (new_fwd_amount > 0) {
                    ~strdump_safe("Out of time ‚è∞");
                    send_money_or_jettons_back_body(in_msg_body, message_from, msg_value, fwd_fee, "Out of time ‚è∞");
                }

                raw_reserve(100000, 0); ;; save little ammount
                send_nft(nft_address, deployer_address, -1); ;; transfer nft back to owner
                throw(0);
            }

            ~strdump_int("Price full on start: ", price + royalty_fee + market_fee);

            if (~ workchains_equal?(nft_address, message_from)) {
                ~strdump_safe("Not same WC üå≠Ô∏è");
                send_money_or_jettons_back_body(in_msg_body, message_from, msg_value, fwd_fee, "Not same WC üå≠Ô∏è");
            }

            if ((marketplace_numerator > 0) & (marketplace_denominator > 0)) {
                market_fee = min(price, muldiv(price, marketplace_numerator, marketplace_denominator));
            }
            ~strdump_int("Market fee calculated: ", market_fee);
            price -= market_fee;

            if ((royalty_numerator > 0) & (royalty_denominator > 0) & (price > 0)) {
                royalty_fee = min(price, muldiv(price, royalty_numerator, royalty_denominator));
            }
            ~strdump_int("Royalty fee calculated: ", royalty_fee);
            price -= royalty_fee;
            ~strdump_int("Price final calculated: ", price);
            ~strdump_int("Price full final: ", price + royalty_fee + market_fee);

            if (is_ton == 1) {
                ~strdump_safe("Process buy request for TON üíé");

                ;; Try to buy with TON

                ;; Ok, in theory someone can send 1 jetton and many TON
                ;; If he bought NFT - no problem, he can get his jettons back thrue admin interface
                ;; If he don't bought NFT - he will get all jettons back with all TONs

                ;; Buy with TON

                ;; If price in TON is 0 - then contract is unconfigurated yet (just let this)
                if ((msg_value - price - royalty_fee - market_fee - little_gas_amount <= 0) | (price == 0)) {
                    ~strdump_safe("No funds üåö");
                    send_money_or_jettons_back_body(in_msg_body, message_from, msg_value, fwd_fee, "No funds üåö");
                } else {
                    ~strdump_safe("üíé Funds is fine, process...");

                    if (market_fee > 0) {
                        ~strdump_int("üíé Send market fee to marketplace", market_fee);
                        send_message_with_text(marketplace, market_fee, "Market fee, sir ü§å", 1);
                    }

                    if (royalty_fee > 0) {
                        ~strdump_int("üíé Send royalty fee to royalty_destanation", royalty_fee);
                        send_message_with_text(royalty_destanation, royalty_fee, "Hey, your royalty, sir ü§å", 1);
                    }

                    if (price > 0) {
                        ~strdump_int("üíé Send rest of price to deployer", price);
                        tuple wow = unsafe_to_tuple(["ü§≠", "üò±", "ü•≥", "üëÄ", "ü´∂"]);
                        int wow_num = rand(5);
                        send_message_with_text(deployer_address, price, wow.at(wow_num), 1);
                    }

                    raw_reserve(100000, 0); ;; save little ammount
                    send_nft(nft_address, message_from, -1); ;; transfer nft

                    store_data(2, ;; change mode to 2 (nft was bought)
                            nft_address,
                            deployer_address,
                            message_from, ;; change who was bought nft
                            sell_config,
                            price_config);

                    ~strdump_safe("Item is bought ü•≥ for üíé!");
                    throw(0);
                }
            } else {
                ;; Try to buy with jettons

                ;; TODO: buy with jetton
                ;; TODO: add tests
                int op = 0;

                if (slice_bits(in_msg_body) >= 32) {
                    op = in_msg_body~load_uint(32);
                }

                if (op == op::ft::transfer_notification) {
                    ;;                     transfer_notification#7362d09c query_id:uint64 amount:(VarUInteger 16)
                    ;;                               sender:MsgAddress forward_payload:(Either Cell ^Cell)
                    ;;                               = InternalMsgBody;

                    if (equal_slices(message_from, my_jetton_address)) {
                        int query_id = in_msg_body~load_uint(64);
                        int amount = in_msg_body~load_coins();
                        slice sender = in_msg_body~load_msg_addr();

                        ;; TODO: think if it's possible to transfer jettons back with 1 fwd_fee
                        ;; Ensure, that we have enough money for transfer
                        int nalogi = fwd_fee * 4;
                        int new_fwd_amount = msg_value - nalogi - little_gas_amount;
                        throw_unless(57, new_fwd_amount > 0);

                        ;; Buy with JETTON!
                        int change = amount - price - royalty_fee - market_fee;
                        if (change < 0) {
                            send_jettons_with_text(message_from, sender, new_fwd_amount + fwd_fee, amount, "Not enought jettons üåö");
                            throw(0);
                        } else {
                            send_jettons_with_text(message_from, marketplace, fwd_fee, market_fee, "Market fee üí´");
                            send_jettons_with_text(message_from, royalty_destanation, fwd_fee, royalty_fee, "Your royalty üçÅ");

                            tuple wow = unsafe_to_tuple(["‚ö°Ô∏è", "ü™ê", "üí•", "üåà", "üå™"]);
                            int wow_num = rand(5);
                            send_jettons_with_text(message_from, deployer_address, fwd_fee, price, wow.at(wow_num));

                            if (change > 0) {
                                send_jettons_with_text(message_from, sender, fwd_fee, change, "Your change sir üòº");
                            }

                            raw_reserve(100000, 0); ;; save little ammount
                            send_nft(nft_address, sender, -1); ;; transfer nft

                            store_data(2, ;; change mode to 2 (nft was bought)
                                    nft_address,
                                    deployer_address,
                                    sender, ;; change who was bought nft
                                    sell_config,
                                    price_config);
                            throw(0);
                        }
                    } else {
                        send_money_or_jettons_back_op(op, in_msg_body, message_from, msg_value, fwd_fee, "Not our jetton üçÑ");
                    }
                } else {
                    send_money_back(message_from, msg_value, fwd_fee, "Not jettons üôÑ");
                }
            }
        }
    }

    int op = 0;
    if (slice_bits(in_msg_body)) {
        op = in_msg_body~load_uint(32);
    }

    ;; TODO: improve functionality
    if (mode == 2) { ;; NFT was bought
        if (equal_slices(message_from, buyer)) {
            if (op == op::seller::send_nft) { ;; send nft one more time
                raw_reserve(100000, 0); ;; save little ammount
                send_nft(nft_address, message_from, -1); ;; transfer nft
                throw(0);
            } else { ;; or process admin stuff
                int exit_code = process_admin(op, in_msg_body);
                throw(exit_code);
            }
        } else {
            send_money_or_jettons_back_op(op, in_msg_body, message_from, msg_value, fwd_fee, "Error üíê");
        }
    } elseif (mode == 3) { ;; Seller was canceled
        if (equal_slices(message_from, deployer_address)) {
            if (op == op::seller::send_nft) { ;; send nft one more time
                raw_reserve(100000, 0); ;; save little ammount
                send_nft(nft_address, message_from, -1); ;; transfer nft
                throw(0);
            } else { ;; or process admin stuff
                int exit_code = process_admin(op, in_msg_body);
                throw(exit_code);
            }
        } else {
            send_money_or_jettons_back_op(op, in_msg_body, message_from, msg_value, fwd_fee, "Error üåç");
        }
    }

}

() recv_external(slice in_msg_body) impure {
    ;; TODO: allow cancel sale with external message when it's out of time
}
